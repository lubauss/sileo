'use client';
function __insertCSS(code) {
  if (!code || typeof document == 'undefined') return
  let head = document.head || document.getElementsByTagName('head')[0]
  let style = document.createElement('style')
  style.type = 'text/css'
  head.appendChild(style)
  ;style.styleSheet ? (style.styleSheet.cssText = code) : style.appendChild(document.createTextNode(code))
}

import { _ as _extends, a as _object_without_properties_loose } from './cc-B6peeNak.mjs';
import { jsxs, jsx, Fragment } from 'react/jsx-runtime';
import { memo, useMemo, useState, useRef, useLayoutEffect, useEffect, useCallback } from 'react';
import { motion } from 'motion/react';

__insertCSS(":root{--sileo-spring-easing:linear(\n\t\t0,\n\t\t0.002 0.6%,\n\t\t0.007 1.2%,\n\t\t0.015 1.8%,\n\t\t0.026 2.4%,\n\t\t0.041 3.1%,\n\t\t0.06 3.8%,\n\t\t0.108 5.3%,\n\t\t0.157 6.6%,\n\t\t0.214 8%,\n\t\t0.467 13.7%,\n\t\t0.577 16.3%,\n\t\t0.631 17.7%,\n\t\t0.682 19.1%,\n\t\t0.73 20.5%,\n\t\t0.771 21.8%,\n\t\t0.808 23.1%,\n\t\t0.844 24.5%,\n\t\t0.874 25.8%,\n\t\t0.903 27.2%,\n\t\t0.928 28.6%,\n\t\t0.952 30.1%,\n\t\t0.972 31.6%,\n\t\t0.988 33.1%,\n\t\t1.01 35.7%,\n\t\t1.025 38.5%,\n\t\t1.034 41.6%,\n\t\t1.038 45%,\n\t\t1.035 50.1%,\n\t\t1.012 64.2%,\n\t\t1.003 73%,\n\t\t0.999 83.7%,\n\t\t1\n\t);--sileo-duration:600ms;--sileo-height:40px;--sileo-width:350px;--sileo-state-success:oklch(0.723 0.219 142.136);--sileo-state-loading:oklch(0.556 0 0);--sileo-state-error:oklch(0.637 0.237 25.331);--sileo-state-warning:oklch(0.795 0.184 86.047);--sileo-state-info:oklch(0.685 0.169 237.323);--sileo-state-action:oklch(0.623 0.214 259.815)}[data-sileo-toast]{position:relative;cursor:pointer;pointer-events:auto;touch-action:none;border:0;background:0 0;padding:0;width:var(--sileo-width);height:var(--_h,var(--sileo-height));opacity:0;transform:translateZ(0) scale(.95);transform-origin:center;contain:layout style;overflow:visible}[data-sileo-toast][data-state=loading]{cursor:default}[data-sileo-toast][data-ready=true]{opacity:1;transform:translateZ(0) scale(1);transition:transform calc(var(--sileo-duration) * .66) var(--sileo-spring-easing),opacity calc(var(--sileo-duration) * .66) var(--sileo-spring-easing),margin-bottom calc(var(--sileo-duration) * .66) var(--sileo-spring-easing),margin-top calc(var(--sileo-duration) * .66) var(--sileo-spring-easing),height var(--sileo-duration) var(--sileo-spring-easing)}[data-sileo-viewport][data-position^=top] [data-sileo-toast]:not([data-ready=true]){transform:translateY(-6px) scale(.95)}[data-sileo-viewport][data-position^=bottom] [data-sileo-toast]:not([data-ready=true]){transform:translateY(6px) scale(.95)}[data-sileo-toast][data-ready=true][data-exiting=true]{opacity:0;pointer-events:none}[data-sileo-viewport][data-position^=top] [data-sileo-toast][data-ready=true][data-exiting=true]{transform:translateY(-6px) scale(.95)}[data-sileo-viewport][data-position^=bottom] [data-sileo-toast][data-ready=true][data-exiting=true]{transform:translateY(6px) scale(.95)}[data-sileo-canvas]{position:absolute;left:0;right:0;pointer-events:none;transform:translateZ(0);contain:layout style;overflow:visible}[data-sileo-canvas][data-edge=top]{bottom:0;transform:scaleY(-1) translateZ(0)}[data-sileo-canvas][data-edge=bottom]{top:0}[data-sileo-svg]{overflow:visible}[data-sileo-header]{position:absolute;z-index:20;display:flex;align-items:center;padding:.5rem;height:var(--sileo-height);overflow:hidden;left:var(--_px,0);transform:var(--_ht);max-width:var(--_pw)}[data-sileo-toast][data-ready=true] [data-sileo-header]{transition:transform var(--sileo-duration) var(--sileo-spring-easing),left var(--sileo-duration) var(--sileo-spring-easing),max-width var(--sileo-duration) var(--sileo-spring-easing)}[data-sileo-header][data-edge=top]{bottom:0}[data-sileo-header][data-edge=bottom]{top:0}[data-sileo-header-stack]{position:relative;display:inline-flex;align-items:center;height:100%}[data-sileo-header-inner]{display:flex;align-items:center;gap:.5rem;white-space:nowrap;opacity:1;filter:blur(0px);transform:translateZ(0)}[data-sileo-header-inner][data-layer=current]{position:relative;z-index:1;animation:sileo-header-enter var(--sileo-duration) var(--sileo-spring-easing) both}[data-sileo-header-inner][data-exiting=true],[data-sileo-header-inner][data-layer=current]:not(:only-child){will-change:opacity,filter}[data-sileo-header-inner][data-layer=prev]{position:absolute;left:0;top:0;z-index:0;pointer-events:none}[data-sileo-header-inner][data-exiting=true]{animation:sileo-header-exit calc(var(--sileo-duration) * .7) ease forwards}[data-sileo-badge]{display:flex;height:24px;width:24px;flex-shrink:0;align-items:center;justify-content:center;padding:2px;box-sizing:border-box;border-radius:9999px;color:var(--sileo-tone,currentColor);background-color:var(--sileo-tone-bg,transparent)}[data-sileo-title]{font-size:.825rem;line-height:1rem;font-weight:500;text-transform:capitalize;color:var(--sileo-tone,currentColor)}:is([data-sileo-badge],[data-sileo-title],[data-sileo-button])[data-state]{--_c:var(--sileo-state-success)}:is(\n[data-sileo-badge],[data-sileo-title],[data-sileo-button]\n)[data-state=loading]{--_c:var(--sileo-state-loading)}:is(\n[data-sileo-badge],[data-sileo-title],[data-sileo-button]\n)[data-state=error]{--_c:var(--sileo-state-error)}:is(\n[data-sileo-badge],[data-sileo-title],[data-sileo-button]\n)[data-state=warning]{--_c:var(--sileo-state-warning)}:is(\n[data-sileo-badge],[data-sileo-title],[data-sileo-button]\n)[data-state=info]{--_c:var(--sileo-state-info)}:is(\n[data-sileo-badge],[data-sileo-title],[data-sileo-button]\n)[data-state=action]{--_c:var(--sileo-state-action)}:is([data-sileo-badge],[data-sileo-title])[data-state]{--sileo-tone:var(--_c);--sileo-tone-bg:color-mix(in oklch, var(--_c) 20%, transparent)}[data-sileo-content]{position:absolute;left:0;z-index:10;width:100%;pointer-events:none;opacity:var(--_co, 0)}[data-sileo-content]:not([data-visible=true]){content-visibility:hidden}[data-sileo-toast][data-ready=true] [data-sileo-content]{transition:opacity calc(var(--sileo-duration) * .08) ease calc(var(--sileo-duration) * .04)}[data-sileo-content][data-edge=top]{top:0}[data-sileo-content][data-edge=bottom]{top:var(--sileo-height)}[data-sileo-content][data-visible=true]{pointer-events:auto}[data-sileo-toast][data-ready=true] [data-sileo-content][data-visible=true]{transition:opacity calc(var(--sileo-duration) * .6) ease calc(var(--sileo-duration) * .3)}[data-sileo-description]{width:100%;text-align:left;padding:1rem;font-size:.875rem;line-height:1.25rem;contain:layout style paint;content-visibility:auto}[data-sileo-button]{display:flex;align-items:center;justify-content:center;height:1.75rem;padding:0 .625rem;margin-top:.75rem;border-radius:9999px;border:0;font-size:.75rem;font-weight:500;cursor:pointer;user-select:none;color:var(--sileo-btn-color,currentColor);background-color:var(--sileo-btn-bg,transparent);transition:background-color 150ms ease}[data-sileo-button]:hover{background-color:var(--sileo-btn-bg-hover,transparent)}[data-sileo-button][data-state]{--sileo-btn-color:var(--_c);--sileo-btn-bg:color-mix(in oklch, var(--_c) 15%, transparent);--sileo-btn-bg-hover:color-mix(in oklch, var(--_c) 25%, transparent)}[data-sileo-icon=spin]{animation:sileo-spin 1s linear infinite}@keyframes sileo-spin{to{transform:rotate(360deg)}}@keyframes sileo-header-enter{from{opacity:0;filter:blur(6px)}to{opacity:1;filter:blur(0px)}}@keyframes sileo-header-exit{from{opacity:1;filter:blur(0px)}to{opacity:0;filter:blur(6px)}}[data-sileo-viewport]{position:fixed;z-index:50;display:flex;gap:.75rem;padding:.75rem;pointer-events:none;max-width:calc(100vw - 1.5rem);contain:layout style}[data-sileo-viewport][data-position^=top] [data-sileo-toast]:not([data-ready=true]){margin-bottom:calc(-1 * (var(--sileo-height) + .75rem))}[data-sileo-viewport][data-position^=bottom] [data-sileo-toast]:not([data-ready=true]){margin-top:calc(-1 * (var(--sileo-height) + .75rem))}[data-sileo-viewport][data-position^=top]{top:0;flex-direction:column-reverse}[data-sileo-viewport][data-position^=bottom]{bottom:0;flex-direction:column}[data-sileo-viewport][data-position$=left]{left:0;align-items:flex-start}[data-sileo-viewport][data-position$=right]{right:0;align-items:flex-end}[data-sileo-viewport][data-position$=center]{left:50%;transform:translateX(-50%);align-items:center}@media (prefers-reduced-motion:no-preference){[data-sileo-toast][data-ready=true]:hover,[data-sileo-toast][data-ready=true][data-exiting=true]{will-change:transform,opacity,height}}@media (prefers-reduced-motion:reduce){[data-sileo-viewport],[data-sileo-viewport] *,[data-sileo-viewport] ::after,[data-sileo-viewport] ::before{animation-duration:0s;animation-iteration-count:1;transition-duration:0s}}[data-sileo-viewport][data-theme=dark] [data-sileo-description]{color:rgba(255,255,255,.8)}[data-sileo-viewport][data-theme=light] [data-sileo-description]{color:rgba(0,0,0,.7)}[data-sileo-close]{position:absolute;top:0;right:0;z-index:30;display:flex;align-items:center;justify-content:center;width:var(--sileo-height);height:var(--sileo-height);padding:0;border:0;background:0 0;cursor:pointer;pointer-events:auto;color:rgba(0,0,0,.4);opacity:0;transition:opacity 150ms ease}[data-sileo-viewport][data-theme=dark] [data-sileo-close]{color:rgba(255,255,255,.4)}[data-sileo-toast]:hover [data-sileo-close]{opacity:1}[data-sileo-close]:hover{color:rgba(0,0,0,.7)}[data-sileo-viewport][data-theme=dark] [data-sileo-close]:hover{color:rgba(255,255,255,.7)}");

/* --------------------------------- Layout --------------------------------- */ const HEIGHT = 40;
const WIDTH = 350;
const DEFAULT_ROUNDNESS = 16;
/* --------------------------------- Timing --------------------------------- */ const DURATION_MS = 600;
const DURATION_S = DURATION_MS / 1000;
const DEFAULT_TOAST_DURATION = 6000;
const EXIT_DURATION = DEFAULT_TOAST_DURATION * 0.1;
const AUTO_EXPAND_DELAY = DEFAULT_TOAST_DURATION * 0.025;
const AUTO_COLLAPSE_DELAY = DEFAULT_TOAST_DURATION - 2000;
const SPRING = {
    type: "spring",
    bounce: 0.25,
    duration: DURATION_S
};
/* --------------------------------- Render --------------------------------- */ const BLUR_RATIO = 0.5;
const PILL_PADDING = 10;
const MIN_EXPAND_RATIO = 2.25;
const SWAP_COLLAPSE_MS = 200;
const HEADER_EXIT_MS = DURATION_MS * 0.7;

const Icon = (_0)=>{
    let { title, children } = _0, props = _object_without_properties_loose(_0, [
        "title",
        "children"
    ]);
    return /*#__PURE__*/ jsxs("svg", _extends({}, props, {
        xmlns: "http://www.w3.org/2000/svg",
        width: "16",
        height: "16",
        viewBox: "0 0 24 24",
        fill: "none",
        stroke: "currentColor",
        strokeWidth: "2",
        strokeLinecap: "round",
        strokeLinejoin: "round",
        children: [
            /*#__PURE__*/ jsx("title", {
                children: title
            }),
            children
        ]
    }));
};
const ArrowRight = ()=>/*#__PURE__*/ jsxs(Icon, {
        title: "Arrow Right",
        children: [
            /*#__PURE__*/ jsx("path", {
                d: "M5 12h14"
            }),
            /*#__PURE__*/ jsx("path", {
                d: "m12 5 7 7-7 7"
            })
        ]
    });
const LifeBuoy = ()=>/*#__PURE__*/ jsxs(Icon, {
        title: "Life Buoy",
        children: [
            /*#__PURE__*/ jsx("circle", {
                cx: "12",
                cy: "12",
                r: "10"
            }),
            /*#__PURE__*/ jsx("path", {
                d: "m4.93 4.93 4.24 4.24"
            }),
            /*#__PURE__*/ jsx("path", {
                d: "m14.83 9.17 4.24-4.24"
            }),
            /*#__PURE__*/ jsx("path", {
                d: "m14.83 14.83 4.24 4.24"
            }),
            /*#__PURE__*/ jsx("path", {
                d: "m9.17 14.83-4.24 4.24"
            }),
            /*#__PURE__*/ jsx("circle", {
                cx: "12",
                cy: "12",
                r: "4"
            })
        ]
    });
const LoaderCircle = (props)=>/*#__PURE__*/ jsx(Icon, _extends({
        title: "Loader Circle"
    }, props, {
        children: /*#__PURE__*/ jsx("path", {
            d: "M21 12a9 9 0 1 1-6.219-8.56"
        })
    }));
const X = ()=>/*#__PURE__*/ jsxs(Icon, {
        title: "X",
        children: [
            /*#__PURE__*/ jsx("path", {
                d: "M18 6 6 18"
            }),
            /*#__PURE__*/ jsx("path", {
                d: "m6 6 12 12"
            })
        ]
    });
const CircleAlert = ()=>/*#__PURE__*/ jsxs(Icon, {
        title: "Circle Alert",
        children: [
            /*#__PURE__*/ jsx("circle", {
                cx: "12",
                cy: "12",
                r: "10"
            }),
            /*#__PURE__*/ jsx("line", {
                x1: "12",
                x2: "12",
                y1: "8",
                y2: "12"
            }),
            /*#__PURE__*/ jsx("line", {
                x1: "12",
                x2: "12.01",
                y1: "16",
                y2: "16"
            })
        ]
    });
const Check = ()=>/*#__PURE__*/ jsx(Icon, {
        title: "Check",
        children: /*#__PURE__*/ jsx("path", {
            d: "M20 6 9 17l-5-5"
        })
    });

/* ---------------------------------- Icons --------------------------------- */ const STATE_ICON = {
    success: /*#__PURE__*/ jsx(Check, {}),
    loading: /*#__PURE__*/ jsx(LoaderCircle, {
        "data-sileo-icon": "spin",
        "aria-hidden": "true"
    }),
    error: /*#__PURE__*/ jsx(X, {}),
    warning: /*#__PURE__*/ jsx(CircleAlert, {}),
    info: /*#__PURE__*/ jsx(LifeBuoy, {}),
    action: /*#__PURE__*/ jsx(ArrowRight, {})
};
/* ----------------------------- Memoised Defs ------------------------------ */ const GooeyDefs = /*#__PURE__*/ memo(function GooeyDefs({ filterId, blur }) {
    return /*#__PURE__*/ jsx("defs", {
        children: /*#__PURE__*/ jsxs("filter", {
            id: filterId,
            x: "-20%",
            y: "-20%",
            width: "140%",
            height: "140%",
            colorInterpolationFilters: "sRGB",
            children: [
                /*#__PURE__*/ jsx("feGaussianBlur", {
                    in: "SourceGraphic",
                    stdDeviation: blur,
                    result: "blur"
                }),
                /*#__PURE__*/ jsx("feColorMatrix", {
                    in: "blur",
                    mode: "matrix",
                    values: "1 0 0 0 0  0 1 0 0 0  0 0 1 0 0  0 0 0 20 -10",
                    result: "goo"
                }),
                /*#__PURE__*/ jsx("feComposite", {
                    in: "SourceGraphic",
                    in2: "goo",
                    operator: "atop"
                })
            ]
        })
    });
});
/* ------------------------------- Component -------------------------------- */ const Sileo = /*#__PURE__*/ memo(function Sileo({ id, fill = "#FFFFFF", state = "success", title = state, description, position = "left", expand = "bottom", className, icon, styles, button, roundness, exiting = false, autoExpandDelayMs, autoCollapseDelayMs, canExpand, interruptKey, refreshKey, closeButton = false, onMouseEnter, onMouseLeave, onDismiss }) {
    var _headerLayer_current_view_icon, _headerLayer_prev_view_icon;
    var _headerLayer_current_view_styles, _headerLayer_current_view_styles1, _headerLayer_prev_view_styles, _headerLayer_prev_view_styles1, _view_styles, _view_styles1;
    const next = useMemo(()=>({
            title,
            description,
            state,
            icon,
            styles,
            button,
            fill
        }), [
        title,
        description,
        state,
        icon,
        styles,
        button,
        fill
    ]);
    const [view, setView] = useState(next);
    const [applied, setApplied] = useState(refreshKey);
    const [isExpanded, setIsExpanded] = useState(false);
    const [ready, setReady] = useState(false);
    const [pillWidth, setPillWidth] = useState(0);
    const [contentHeight, setContentHeight] = useState(0);
    const hasDesc = Boolean(view.description) || Boolean(view.button);
    const isLoading = view.state === "loading";
    const open = hasDesc && isExpanded && !isLoading;
    const allowExpand = isLoading ? false : canExpand != null ? canExpand : !interruptKey || interruptKey === id;
    const headerKey = `${view.state}-${view.title}`;
    const filterId = `sileo-gooey-${id}`;
    const resolvedRoundness = Math.max(0, roundness != null ? roundness : DEFAULT_ROUNDNESS);
    const blur = resolvedRoundness * BLUR_RATIO;
    const headerRef = useRef(null);
    const contentRef = useRef(null);
    const headerExitRef = useRef(null);
    const autoExpandRef = useRef(null);
    const autoCollapseRef = useRef(null);
    const swapTimerRef = useRef(null);
    const lastRefreshKeyRef = useRef(refreshKey);
    const pendingRef = useRef(null);
    const [headerLayer, setHeaderLayer] = useState({
        current: {
            key: headerKey,
            view
        },
        prev: null
    });
    /* ------------------------------ Measurements ------------------------------ */ const innerRef = useRef(null);
    const headerPadRef = useRef(null);
    const pillRoRef = useRef(null);
    const pillRafRef = useRef(0);
    const pillObservedRef = useRef(null);
    // biome-ignore lint/correctness/useExhaustiveDependencies: headerLayer.current.key is used to force a re-render
    useLayoutEffect(()=>{
        const el = innerRef.current;
        const header = headerRef.current;
        if (!el || !header) return;
        if (headerPadRef.current === null) {
            const cs = getComputedStyle(header);
            headerPadRef.current = parseFloat(cs.paddingLeft) + parseFloat(cs.paddingRight);
        }
        const px = headerPadRef.current;
        const measure = ()=>{
            const w = el.scrollWidth + px + PILL_PADDING;
            if (w > PILL_PADDING) {
                setPillWidth((prev)=>prev === w ? prev : w);
            }
        };
        measure();
        if (!pillRoRef.current) {
            pillRoRef.current = new ResizeObserver(()=>{
                cancelAnimationFrame(pillRafRef.current);
                pillRafRef.current = requestAnimationFrame(()=>{
                    var _headerPadRef_current;
                    const inner = innerRef.current;
                    const pad = (_headerPadRef_current = headerPadRef.current) != null ? _headerPadRef_current : 0;
                    if (!inner) return;
                    const w = inner.scrollWidth + pad + PILL_PADDING;
                    if (w > PILL_PADDING) {
                        setPillWidth((prev)=>prev === w ? prev : w);
                    }
                });
            });
        }
        if (pillObservedRef.current !== el) {
            if (pillObservedRef.current) {
                pillRoRef.current.unobserve(pillObservedRef.current);
            }
            pillRoRef.current.observe(el);
            pillObservedRef.current = el;
        }
    }, [
        headerLayer.current.key
    ]);
    useEffect(()=>{
        return ()=>{
            var _pillRoRef_current;
            cancelAnimationFrame(pillRafRef.current);
            (_pillRoRef_current = pillRoRef.current) == null ? void 0 : _pillRoRef_current.disconnect();
        };
    }, []);
    useLayoutEffect(()=>{
        if (!hasDesc) {
            setContentHeight(0);
            return;
        }
        const el = contentRef.current;
        if (!el) return;
        const measure = ()=>{
            const h = el.scrollHeight;
            setContentHeight((prev)=>prev === h ? prev : h);
        };
        measure();
        let rafId = 0;
        const ro = new ResizeObserver(()=>{
            cancelAnimationFrame(rafId);
            rafId = requestAnimationFrame(measure);
        });
        ro.observe(el);
        return ()=>{
            cancelAnimationFrame(rafId);
            ro.disconnect();
        };
    }, [
        hasDesc
    ]);
    useEffect(()=>{
        const raf = requestAnimationFrame(()=>setReady(true));
        return ()=>cancelAnimationFrame(raf);
    }, []);
    useLayoutEffect(()=>{
        setHeaderLayer((state)=>{
            if (state.current.key === headerKey) {
                if (state.current.view === view) return state;
                return _extends({}, state, {
                    current: {
                        key: headerKey,
                        view
                    }
                });
            }
            return {
                prev: state.current,
                current: {
                    key: headerKey,
                    view
                }
            };
        });
    }, [
        headerKey,
        view
    ]);
    useEffect(()=>{
        if (!headerLayer.prev) return;
        if (headerExitRef.current) {
            clearTimeout(headerExitRef.current);
        }
        headerExitRef.current = window.setTimeout(()=>{
            headerExitRef.current = null;
            setHeaderLayer((state)=>_extends({}, state, {
                    prev: null
                }));
        }, HEADER_EXIT_MS);
        return ()=>{
            if (headerExitRef.current) {
                clearTimeout(headerExitRef.current);
                headerExitRef.current = null;
            }
        };
    }, [
        headerLayer.prev
    ]);
    /* ----------------------------- Refresh logic ------------------------------ */ useEffect(()=>{
        if (refreshKey === undefined) {
            setView(next);
            setApplied(undefined);
            pendingRef.current = null;
            lastRefreshKeyRef.current = refreshKey;
            return;
        }
        if (lastRefreshKeyRef.current === refreshKey) return;
        lastRefreshKeyRef.current = refreshKey;
        if (swapTimerRef.current) {
            clearTimeout(swapTimerRef.current);
            swapTimerRef.current = null;
        }
        if (open) {
            pendingRef.current = {
                key: refreshKey,
                payload: next
            };
            setIsExpanded(false);
            swapTimerRef.current = window.setTimeout(()=>{
                swapTimerRef.current = null;
                const pending = pendingRef.current;
                if (!pending) return;
                setView(pending.payload);
                setApplied(pending.key);
                pendingRef.current = null;
            }, SWAP_COLLAPSE_MS);
        } else {
            pendingRef.current = null;
            setView(next);
            setApplied(refreshKey);
        }
    }, [
        open,
        refreshKey,
        next
    ]);
    /* ----------------------------- Auto expand/collapse ----------------------- */ // biome-ignore lint/correctness/useExhaustiveDependencies: applied is used to force a re-render
    useEffect(()=>{
        if (!hasDesc) return;
        if (autoExpandRef.current) clearTimeout(autoExpandRef.current);
        if (autoCollapseRef.current) clearTimeout(autoCollapseRef.current);
        if (exiting || !allowExpand) {
            setIsExpanded(false);
            return;
        }
        if (autoExpandDelayMs == null && autoCollapseDelayMs == null) return;
        const expandDelay = autoExpandDelayMs != null ? autoExpandDelayMs : 0;
        const collapseDelay = autoCollapseDelayMs != null ? autoCollapseDelayMs : 0;
        if (expandDelay > 0) {
            autoExpandRef.current = window.setTimeout(()=>setIsExpanded(true), expandDelay);
        } else {
            setIsExpanded(true);
        }
        if (collapseDelay > 0) {
            autoCollapseRef.current = window.setTimeout(()=>setIsExpanded(false), collapseDelay);
        }
        return ()=>{
            if (autoExpandRef.current) clearTimeout(autoExpandRef.current);
            if (autoCollapseRef.current) clearTimeout(autoCollapseRef.current);
        };
    }, [
        autoCollapseDelayMs,
        autoExpandDelayMs,
        hasDesc,
        allowExpand,
        exiting,
        applied
    ]);
    /* ------------------------------ Derived values ---------------------------- */ const minExpanded = HEIGHT * MIN_EXPAND_RATIO;
    const rawExpanded = hasDesc ? Math.max(minExpanded, HEIGHT + contentHeight) : minExpanded;
    const frozenExpandedRef = useRef(rawExpanded);
    if (open) {
        frozenExpandedRef.current = rawExpanded;
    }
    const expanded = open ? rawExpanded : frozenExpandedRef.current;
    const svgHeight = hasDesc ? Math.max(expanded, minExpanded) : HEIGHT;
    const expandedContent = Math.max(0, expanded - HEIGHT);
    const resolvedPillWidth = Math.max(pillWidth || HEIGHT, HEIGHT);
    const pillHeight = HEIGHT + blur * 3;
    const pillX = position === "right" ? WIDTH - resolvedPillWidth : position === "center" ? (WIDTH - resolvedPillWidth) / 2 : 0;
    /* ------------------------------- Memoised animate targets ----------------- */ const pillAnimate = useMemo(()=>({
            x: pillX,
            width: resolvedPillWidth,
            height: open ? pillHeight : HEIGHT
        }), [
        pillX,
        resolvedPillWidth,
        open,
        pillHeight
    ]);
    const bodyAnimate = useMemo(()=>({
            height: open ? expandedContent : 0,
            opacity: open ? 1 : 0
        }), [
        open,
        expandedContent
    ]);
    const bodyTransition = useMemo(()=>open ? SPRING : _extends({}, SPRING, {
            bounce: 0
        }), [
        open
    ]);
    const pillTransition = useMemo(()=>ready ? SPRING : {
            duration: 0
        }, [
        ready
    ]);
    const viewBox = `0 0 ${WIDTH} ${svgHeight}`;
    const canvasStyle = useMemo(()=>({
            filter: `url(#${filterId})`
        }), [
        filterId
    ]);
    /* ------------------------------- Inline styles ---------------------------- */ const rootStyle = useMemo(()=>({
            "--_h": `${open ? expanded : HEIGHT}px`,
            "--_pw": `${resolvedPillWidth}px`,
            "--_px": `${pillX}px`,
            "--_ht": `translateY(${open ? expand === "bottom" ? 3 : -3 : 0}px) scale(${open ? 0.9 : 1})`,
            "--_co": `${open ? 1 : 0}`
        }), [
        open,
        expanded,
        resolvedPillWidth,
        pillX,
        expand
    ]);
    /* -------------------------------- Handlers -------------------------------- */ const handleEnter = useCallback((e)=>{
        onMouseEnter == null ? void 0 : onMouseEnter(e);
        if (hasDesc) setIsExpanded(true);
    }, [
        hasDesc,
        onMouseEnter
    ]);
    const handleLeave = useCallback((e)=>{
        onMouseLeave == null ? void 0 : onMouseLeave(e);
        setIsExpanded(false);
    }, [
        onMouseLeave
    ]);
    const handleTransitionEnd = useCallback((e)=>{
        if (e.propertyName !== "height" && e.propertyName !== "transform") return;
        if (open) return;
        const pending = pendingRef.current;
        if (!pending) return;
        if (swapTimerRef.current) {
            clearTimeout(swapTimerRef.current);
            swapTimerRef.current = null;
        }
        setView(pending.payload);
        setApplied(pending.key);
        pendingRef.current = null;
    }, [
        open
    ]);
    /* -------------------------------- Swipe ----------------------------------- */ const SWIPE_DISMISS = 30;
    const SWIPE_MAX = 20;
    const buttonRef = useRef(null);
    const pointerStartRef = useRef(null);
    const swipeActiveRef = useRef(false);
    const onDismissRef = useRef(onDismiss);
    onDismissRef.current = onDismiss;
    const swipeHandlersRef = useRef(null);
    if (!swipeHandlersRef.current) {
        const handlers = {
            onMove: (e)=>{
                const el = buttonRef.current;
                if (pointerStartRef.current === null || !el) return;
                const dy = e.clientY - pointerStartRef.current;
                const sign = dy > 0 ? 1 : -1;
                const clamped = Math.min(Math.abs(dy), SWIPE_MAX) * sign;
                el.style.transform = `translateY(${clamped}px)`;
            },
            onUp: (e)=>{
                const el = buttonRef.current;
                if (pointerStartRef.current === null || !el) return;
                const dy = e.clientY - pointerStartRef.current;
                pointerStartRef.current = null;
                swipeActiveRef.current = false;
                el.style.transform = "";
                el.removeEventListener("pointermove", handlers.onMove);
                el.removeEventListener("pointerup", handlers.onUp);
                if (Math.abs(dy) > SWIPE_DISMISS) {
                    onDismissRef.current == null ? void 0 : onDismissRef.current.call(onDismissRef);
                }
            }
        };
        swipeHandlersRef.current = handlers;
    }
    // Clean up swipe listeners on unmount (prevents leak if unmounted mid-gesture)
    useEffect(()=>{
        return ()=>{
            const el = buttonRef.current;
            const h = swipeHandlersRef.current;
            if (el && h) {
                el.removeEventListener("pointermove", h.onMove);
                el.removeEventListener("pointerup", h.onUp);
            }
        };
    }, []);
    const handleButtonClick = useCallback((e)=>{
        var _view_button;
        e.preventDefault();
        e.stopPropagation();
        (_view_button = view.button) == null ? void 0 : _view_button.onClick();
    }, [
        view.button
    ]);
    const handlePointerDown = useCallback((e)=>{
        if (exiting || !onDismiss) return;
        if (swipeActiveRef.current) return;
        const target = e.target;
        if (target.closest("[data-sileo-button]")) return;
        pointerStartRef.current = e.clientY;
        swipeActiveRef.current = true;
        e.currentTarget.setPointerCapture(e.pointerId);
        const el = buttonRef.current;
        const h = swipeHandlersRef.current;
        if (el && h) {
            el.addEventListener("pointermove", h.onMove, {
                passive: true
            });
            el.addEventListener("pointerup", h.onUp, {
                passive: true
            });
        }
    }, [
        exiting,
        onDismiss
    ]);
    /* --------------------------------- Render --------------------------------- */ return /*#__PURE__*/ jsxs("button", {
        ref: buttonRef,
        type: "button",
        "data-sileo-toast": true,
        "data-ready": ready,
        "data-expanded": open,
        "data-exiting": exiting,
        "data-edge": expand,
        "data-position": position,
        "data-state": view.state,
        className: className,
        style: rootStyle,
        onMouseEnter: handleEnter,
        onMouseLeave: handleLeave,
        onTransitionEnd: handleTransitionEnd,
        onPointerDown: handlePointerDown,
        children: [
            /*#__PURE__*/ jsx("div", {
                "data-sileo-canvas": true,
                "data-edge": expand,
                style: canvasStyle,
                children: /*#__PURE__*/ jsxs("svg", {
                    "data-sileo-svg": true,
                    width: WIDTH,
                    height: svgHeight,
                    viewBox: viewBox,
                    children: [
                        /*#__PURE__*/ jsx("title", {
                            children: "Sileo Notification"
                        }),
                        /*#__PURE__*/ jsx(GooeyDefs, {
                            filterId: filterId,
                            blur: blur
                        }),
                        /*#__PURE__*/ jsx(motion.rect, {
                            "data-sileo-pill": true,
                            rx: resolvedRoundness,
                            ry: resolvedRoundness,
                            fill: view.fill,
                            initial: false,
                            animate: pillAnimate,
                            transition: pillTransition
                        }),
                        /*#__PURE__*/ jsx(motion.rect, {
                            "data-sileo-body": true,
                            y: HEIGHT,
                            width: WIDTH,
                            rx: resolvedRoundness,
                            ry: resolvedRoundness,
                            fill: view.fill,
                            initial: false,
                            animate: bodyAnimate,
                            transition: bodyTransition
                        })
                    ]
                })
            }),
            /*#__PURE__*/ jsx("div", {
                ref: headerRef,
                "data-sileo-header": true,
                "data-edge": expand,
                children: /*#__PURE__*/ jsxs("div", {
                    "data-sileo-header-stack": true,
                    children: [
                        /*#__PURE__*/ jsxs("div", {
                            ref: innerRef,
                            "data-sileo-header-inner": true,
                            "data-layer": "current",
                            children: [
                                /*#__PURE__*/ jsx("div", {
                                    "data-sileo-badge": true,
                                    "data-state": headerLayer.current.view.state,
                                    className: (_headerLayer_current_view_styles = headerLayer.current.view.styles) == null ? void 0 : _headerLayer_current_view_styles.badge,
                                    children: (_headerLayer_current_view_icon = headerLayer.current.view.icon) != null ? _headerLayer_current_view_icon : STATE_ICON[headerLayer.current.view.state]
                                }),
                                /*#__PURE__*/ jsx("span", {
                                    "data-sileo-title": true,
                                    "data-state": headerLayer.current.view.state,
                                    className: (_headerLayer_current_view_styles1 = headerLayer.current.view.styles) == null ? void 0 : _headerLayer_current_view_styles1.title,
                                    children: headerLayer.current.view.title
                                })
                            ]
                        }, headerLayer.current.key),
                        headerLayer.prev && /*#__PURE__*/ jsxs("div", {
                            "data-sileo-header-inner": true,
                            "data-layer": "prev",
                            "data-exiting": "true",
                            children: [
                                /*#__PURE__*/ jsx("div", {
                                    "data-sileo-badge": true,
                                    "data-state": headerLayer.prev.view.state,
                                    className: (_headerLayer_prev_view_styles = headerLayer.prev.view.styles) == null ? void 0 : _headerLayer_prev_view_styles.badge,
                                    children: (_headerLayer_prev_view_icon = headerLayer.prev.view.icon) != null ? _headerLayer_prev_view_icon : STATE_ICON[headerLayer.prev.view.state]
                                }),
                                /*#__PURE__*/ jsx("span", {
                                    "data-sileo-title": true,
                                    "data-state": headerLayer.prev.view.state,
                                    className: (_headerLayer_prev_view_styles1 = headerLayer.prev.view.styles) == null ? void 0 : _headerLayer_prev_view_styles1.title,
                                    children: headerLayer.prev.view.title
                                })
                            ]
                        }, headerLayer.prev.key)
                    ]
                })
            }),
            closeButton && onDismiss && /*#__PURE__*/ jsx("div", {
                "data-sileo-close": true,
                role: "button",
                tabIndex: 0,
                "aria-label": "Close notification",
                onClick: (e)=>{
                    e.preventDefault();
                    e.stopPropagation();
                    onDismiss();
                },
                onKeyDown: (e)=>{
                    if (e.key === 'Enter' || e.key === ' ') {
                        e.preventDefault();
                        e.stopPropagation();
                        onDismiss();
                    }
                },
                children: /*#__PURE__*/ jsx(X, {})
            }),
            hasDesc && /*#__PURE__*/ jsx("div", {
                "data-sileo-content": true,
                "data-edge": expand,
                "data-visible": open,
                children: /*#__PURE__*/ jsxs("div", {
                    ref: contentRef,
                    "data-sileo-description": true,
                    className: (_view_styles = view.styles) == null ? void 0 : _view_styles.description,
                    children: [
                        view.description,
                        view.button && /*#__PURE__*/ jsx("span", {
                            role: "button",
                            tabIndex: 0,
                            "data-sileo-button": true,
                            "data-state": view.state,
                            className: (_view_styles1 = view.styles) == null ? void 0 : _view_styles1.button,
                            onClick: handleButtonClick,
                            onKeyDown: (e)=>{
                                if (e.key === "Enter" || e.key === " ") {
                                    e.preventDefault();
                                    handleButtonClick(e);
                                }
                            },
                            children: view.button.title
                        })
                    ]
                })
            })
        ]
    });
});

const pillAlign = (pos)=>pos.includes("right") ? "right" : pos.includes("center") ? "center" : "left";
const expandDir = (pos)=>pos.startsWith("top") ? "bottom" : "top";
const store = {
    toasts: [],
    listeners: new Set(),
    position: "top-right",
    options: undefined,
    emit () {
        for (const fn of this.listeners)fn(this.toasts);
    },
    update (fn) {
        this.toasts = fn(this.toasts);
        this.emit();
    }
};
let idCounter = 0;
const generateId = ()=>`${++idCounter}-${Date.now().toString(36)}-${Math.random().toString(36).slice(2, 8)}`;
const timeoutKey = (t)=>`${t.id}:${t.instanceId}`;
/* ------------------------------- Toast API -------------------------------- */ const dismissToast = (id)=>{
    const item = store.toasts.find((t)=>t.id === id);
    if (!item || item.exiting) return;
    store.update((prev)=>prev.map((t)=>t.id === id ? _extends({}, t, {
                exiting: true
            }) : t));
    setTimeout(()=>store.update((prev)=>prev.filter((t)=>t.id !== id)), EXIT_DURATION);
};
const resolveAutopilot = (opts, duration)=>{
    var _ref, _ref1;
    if (opts.autopilot === false || !duration || duration <= 0) return {};
    const cfg = typeof opts.autopilot === "object" ? opts.autopilot : undefined;
    const clamp = (v)=>Math.min(duration, Math.max(0, v));
    return {
        expandDelayMs: clamp((_ref = cfg == null ? void 0 : cfg.expand) != null ? _ref : AUTO_EXPAND_DELAY),
        collapseDelayMs: clamp((_ref1 = cfg == null ? void 0 : cfg.collapse) != null ? _ref1 : AUTO_COLLAPSE_DELAY)
    };
};
const mergeOptions = (options)=>{
    var _store_options;
    return _extends({}, store.options, options, {
        styles: _extends({}, (_store_options = store.options) == null ? void 0 : _store_options.styles, options.styles)
    });
};
const buildSileoItem = (merged, id, fallbackPosition)=>{
    var _merged_duration, _ref, _merged_position;
    const duration = (_merged_duration = merged.duration) != null ? _merged_duration : DEFAULT_TOAST_DURATION;
    const auto = resolveAutopilot(merged, duration);
    return _extends({}, merged, {
        id,
        instanceId: generateId(),
        position: (_ref = (_merged_position = merged.position) != null ? _merged_position : fallbackPosition) != null ? _ref : store.position,
        autoExpandDelayMs: auto.expandDelayMs,
        autoCollapseDelayMs: auto.collapseDelayMs
    });
};
const createToast = (options)=>{
    var _merged_id, _merged_duration;
    const live = store.toasts.filter((t)=>!t.exiting);
    const merged = mergeOptions(options);
    const id = (_merged_id = merged.id) != null ? _merged_id : generateId();
    const prev = live.find((t)=>t.id === id);
    const item = buildSileoItem(merged, id, prev == null ? void 0 : prev.position);
    if (prev) {
        store.update((p)=>p.map((t)=>t.id === id ? item : t));
    } else {
        store.update((p)=>[
                ...p.filter((t)=>t.id !== id),
                item
            ]);
    }
    return {
        id,
        duration: (_merged_duration = merged.duration) != null ? _merged_duration : DEFAULT_TOAST_DURATION
    };
};
const updateToast = (id, options)=>{
    const existing = store.toasts.find((t)=>t.id === id);
    if (!existing) return;
    const item = buildSileoItem(mergeOptions(options), id, existing.position);
    store.update((prev)=>prev.map((t)=>t.id === id ? item : t));
};
const sileo = {
    show: (opts)=>createToast(opts).id,
    success: (opts)=>createToast(_extends({}, opts, {
            state: "success"
        })).id,
    error: (opts)=>createToast(_extends({}, opts, {
            state: "error"
        })).id,
    warning: (opts)=>createToast(_extends({}, opts, {
            state: "warning"
        })).id,
    info: (opts)=>createToast(_extends({}, opts, {
            state: "info"
        })).id,
    action: (opts)=>createToast(_extends({}, opts, {
            state: "action"
        })).id,
    promise: (promise, opts)=>{
        const { id } = createToast(_extends({}, opts.loading, {
            state: "loading",
            duration: null,
            position: opts.position
        }));
        const p = typeof promise === "function" ? promise() : promise;
        p.then((data)=>{
            if (opts.action) {
                const actionOpts = typeof opts.action === "function" ? opts.action(data) : opts.action;
                updateToast(id, _extends({}, actionOpts, {
                    state: "action",
                    id
                }));
            } else {
                const successOpts = typeof opts.success === "function" ? opts.success(data) : opts.success;
                updateToast(id, _extends({}, successOpts, {
                    state: "success",
                    id
                }));
            }
        }).catch((err)=>{
            const errorOpts = typeof opts.error === "function" ? opts.error(err) : opts.error;
            updateToast(id, _extends({}, errorOpts, {
                state: "error",
                id
            }));
        });
        return p;
    },
    dismiss: dismissToast,
    clear: (position)=>store.update((prev)=>position ? prev.filter((t)=>t.position !== position) : [])
};
/* ------------------------------ Toaster Component ------------------------- */ const THEME_FILLS = {
    light: '#FFFFFF',
    dark: '#1a1a1a'
};
function useResolvedTheme(theme) {
    const [resolved, setResolved] = useState(()=>{
        if (theme === 'light' || theme === 'dark') return theme;
        if (typeof window === 'undefined') return 'light';
        return window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light';
    });
    useEffect(()=>{
        if (theme === 'light' || theme === 'dark') {
            setResolved(theme);
            return;
        }
        const mq = window.matchMedia('(prefers-color-scheme: dark)');
        const handler = (e)=>setResolved(e.matches ? 'dark' : 'light');
        setResolved(mq.matches ? 'dark' : 'light');
        mq.addEventListener('change', handler);
        return ()=>mq.removeEventListener('change', handler);
    }, [
        theme
    ]);
    return resolved;
}
function Toaster({ children, position = "top-right", offset, options, theme, closeButton = false }) {
    const resolvedTheme = useResolvedTheme(theme);
    const [toasts, setToasts] = useState(store.toasts);
    const [activeId, setActiveId] = useState();
    const hoverRef = useRef(false);
    const timersRef = useRef(new Map());
    // Track when each timer was started and its scheduled duration so we can
    // pause on hover and resume with the remaining time instead of resetting.
    const timerMetaRef = useRef(new Map());
    const remainingRef = useRef(new Map());
    const listRef = useRef(toasts);
    const latestRef = useRef(undefined);
    const handlersCache = useRef(new Map());
    useEffect(()=>{
        store.position = position;
        const fill = theme ? THEME_FILLS[resolvedTheme] : undefined;
        store.options = fill ? _extends({}, options, {
            fill
        }) : options;
    }, [
        position,
        options,
        theme,
        resolvedTheme
    ]);
    const clearAllTimers = useCallback(()=>{
        for (const t of timersRef.current.values())clearTimeout(t);
        timersRef.current.clear();
        timerMetaRef.current.clear();
    }, []);
    const scheduleItem = useCallback((item, overrideDur)=>{
        var _ref, _item_duration;
        const key = timeoutKey(item);
        if (timersRef.current.has(key)) return;
        const dur = (_ref = overrideDur != null ? overrideDur : remainingRef.current.get(key)) != null ? _ref : (_item_duration = item.duration) != null ? _item_duration : DEFAULT_TOAST_DURATION;
        if (dur === null || dur <= 0) return;
        // Clean up any stale remaining entry
        remainingRef.current.delete(key);
        timerMetaRef.current.set(key, {
            startedAt: Date.now(),
            duration: dur
        });
        timersRef.current.set(key, window.setTimeout(()=>{
            timerMetaRef.current.delete(key);
            remainingRef.current.delete(key);
            dismissToast(item.id);
        }, dur));
    }, []);
    const schedule = useCallback((items)=>{
        if (hoverRef.current) return;
        for (const item of items){
            if (item.exiting) continue;
            scheduleItem(item);
        }
    }, [
        scheduleItem
    ]);
    // Pause all timers: snapshot remaining time per key, then clear.
    const pauseAllTimers = useCallback(()=>{
        const now = Date.now();
        for (const [key, meta] of timerMetaRef.current){
            const elapsed = now - meta.startedAt;
            const left = Math.max(0, meta.duration - elapsed);
            remainingRef.current.set(key, left);
        }
        for (const t of timersRef.current.values())clearTimeout(t);
        timersRef.current.clear();
        timerMetaRef.current.clear();
    }, []);
    useEffect(()=>{
        const listener = (next)=>setToasts(next);
        store.listeners.add(listener);
        return ()=>{
            store.listeners.delete(listener);
            clearAllTimers();
        };
    }, [
        clearAllTimers
    ]);
    useEffect(()=>{
        listRef.current = toasts;
        const toastKeys = new Set(toasts.map(timeoutKey));
        const toastIds = new Set(toasts.map((t)=>t.id));
        for (const [key, timer] of timersRef.current){
            if (!toastKeys.has(key)) {
                clearTimeout(timer);
                timersRef.current.delete(key);
                timerMetaRef.current.delete(key);
                remainingRef.current.delete(key);
            }
        }
        // Also clean up remaining entries for removed toasts
        for (const key of remainingRef.current.keys()){
            if (!toastKeys.has(key)) remainingRef.current.delete(key);
        }
        for (const id of handlersCache.current.keys()){
            if (!toastIds.has(id)) handlersCache.current.delete(id);
        }
        schedule(toasts);
    }, [
        toasts,
        schedule
    ]);
    const handleMouseEnterRef = useRef(null);
    const handleMouseLeaveRef = useRef(null);
    handleMouseEnterRef.current = useCallback(()=>{
        if (hoverRef.current) return;
        hoverRef.current = true;
        pauseAllTimers();
    }, [
        pauseAllTimers
    ]);
    handleMouseLeaveRef.current = useCallback(()=>{
        if (!hoverRef.current) return;
        hoverRef.current = false;
        schedule(listRef.current);
    }, [
        schedule
    ]);
    const latest = useMemo(()=>{
        for(let i = toasts.length - 1; i >= 0; i--){
            if (!toasts[i].exiting) return toasts[i].id;
        }
        return undefined;
    }, [
        toasts
    ]);
    useEffect(()=>{
        latestRef.current = latest;
        setActiveId(latest);
    }, [
        latest
    ]);
    const getHandlers = useCallback((toastId)=>{
        let cached = handlersCache.current.get(toastId);
        if (cached) return cached;
        cached = {
            enter: (e)=>{
                setActiveId((prev)=>prev === toastId ? prev : toastId);
                handleMouseEnterRef.current == null ? void 0 : handleMouseEnterRef.current.call(handleMouseEnterRef, e);
            },
            leave: (e)=>{
                setActiveId((prev)=>prev === latestRef.current ? prev : latestRef.current);
                handleMouseLeaveRef.current == null ? void 0 : handleMouseLeaveRef.current.call(handleMouseLeaveRef, e);
            },
            dismiss: ()=>dismissToast(toastId)
        };
        handlersCache.current.set(toastId, cached);
        return cached;
    }, []);
    const getViewportStyle = useCallback((pos)=>{
        if (offset === undefined) return undefined;
        const o = typeof offset === "object" ? offset : {
            top: offset,
            right: offset,
            bottom: offset,
            left: offset
        };
        const s = {};
        const px = (v)=>typeof v === "number" ? `${v}px` : v;
        if (pos.startsWith("top") && o.top) s.top = px(o.top);
        if (pos.startsWith("bottom") && o.bottom) s.bottom = px(o.bottom);
        if (pos.endsWith("left") && o.left) s.left = px(o.left);
        if (pos.endsWith("right") && o.right) s.right = px(o.right);
        return s;
    }, [
        offset
    ]);
    const activePositions = useMemo(()=>{
        const map = new Map();
        for (const t of toasts){
            var _t_position;
            const pos = (_t_position = t.position) != null ? _t_position : position;
            const arr = map.get(pos);
            if (arr) {
                arr.push(t);
            } else {
                map.set(pos, [
                    t
                ]);
            }
        }
        return map;
    }, [
        toasts,
        position
    ]);
    return /*#__PURE__*/ jsxs(Fragment, {
        children: [
            children,
            Array.from(activePositions, ([pos, items])=>{
                const pill = pillAlign(pos);
                const expand = expandDir(pos);
                return /*#__PURE__*/ jsx("section", {
                    "data-sileo-viewport": true,
                    "data-position": pos,
                    "data-theme": theme ? resolvedTheme : undefined,
                    "aria-live": "polite",
                    style: getViewportStyle(pos),
                    children: items.map((item)=>{
                        const h = getHandlers(item.id);
                        return /*#__PURE__*/ jsx(Sileo, {
                            id: item.id,
                            state: item.state,
                            title: item.title,
                            description: item.description,
                            position: pill,
                            expand: expand,
                            icon: item.icon,
                            fill: item.fill,
                            styles: item.styles,
                            button: item.button,
                            roundness: item.roundness,
                            exiting: item.exiting,
                            autoExpandDelayMs: item.autoExpandDelayMs,
                            autoCollapseDelayMs: item.autoCollapseDelayMs,
                            refreshKey: item.instanceId,
                            canExpand: activeId === undefined || activeId === item.id,
                            onMouseEnter: h.enter,
                            onMouseLeave: h.leave,
                            onDismiss: h.dismiss,
                            closeButton: closeButton
                        }, item.id);
                    })
                }, pos);
            })
        ]
    });
}

function mapOptions(msg, opts) {
    const title = typeof msg === "string" ? msg : "Notification";
    const description = typeof msg !== "string" ? msg : opts == null ? void 0 : opts.description;
    return {
        title,
        description,
        duration: (opts == null ? void 0 : opts.duration) === Infinity ? null : (opts == null ? void 0 : opts.duration) === undefined ? undefined : opts.duration,
        button: (opts == null ? void 0 : opts.action) ? {
            title: opts.action.label,
            onClick: opts.action.onClick
        } : undefined,
        id: opts == null ? void 0 : opts.id
    };
}
const _toast = (msg, opts)=>sileo.show(mapOptions(msg, opts));
const toast = Object.assign(_toast, {
    success: (msg, opts)=>sileo.success(mapOptions(msg, opts)),
    error: (msg, opts)=>sileo.error(mapOptions(msg, opts)),
    warning: (msg, opts)=>sileo.warning(mapOptions(msg, opts)),
    info: (msg, opts)=>sileo.info(mapOptions(msg, opts)),
    dismiss: sileo.dismiss,
    promise: sileo.promise
});

export { Toaster, sileo, toast };
