{"version":3,"file":"index.d.ts","sources":["../src/types.ts","../src/toast.tsx","../src/compat.ts"],"sourcesContent":["import type { ReactNode } from \"react\";\n\nexport type SileoState =\n\t| \"success\"\n\t| \"loading\"\n\t| \"error\"\n\t| \"warning\"\n\t| \"info\"\n\t| \"action\";\n\nexport interface SileoStyles {\n\ttitle?: string;\n\tdescription?: string;\n\tbadge?: string;\n\tbutton?: string;\n}\n\nexport interface SileoButton {\n\ttitle: string;\n\tonClick: () => void;\n}\n\nexport const SILEO_POSITIONS = [\n\t\"top-left\",\n\t\"top-center\",\n\t\"top-right\",\n\t\"bottom-left\",\n\t\"bottom-center\",\n\t\"bottom-right\",\n] as const;\n\nexport type SileoPosition = (typeof SILEO_POSITIONS)[number];\n\nexport interface SileoOptions {\n\ttitle?: string;\n\tdescription?: ReactNode | string;\n\tposition?: SileoPosition;\n\tduration?: number | null;\n\ticon?: ReactNode | null;\n\tstyles?: SileoStyles;\n\tfill?: string;\n\troundness?: number;\n\tautopilot?: boolean | { expand?: number; collapse?: number };\n\tbutton?: SileoButton;\n}\n","import {\n\ttype CSSProperties,\n\ttype MouseEventHandler,\n\ttype ReactNode,\n\tuseCallback,\n\tuseEffect,\n\tuseMemo,\n\tuseRef,\n\tuseState,\n} from \"react\";\nimport {\n\tAUTO_COLLAPSE_DELAY,\n\tAUTO_EXPAND_DELAY,\n\tDEFAULT_TOAST_DURATION,\n\tDEFAULT_TOAST_LIMIT,\n\tEXIT_DURATION,\n} from \"./constants\";\nimport { Sileo } from \"./sileo\";\nimport type { SileoOptions, SileoPosition, SileoState } from \"./types\";\n\nconst pillAlign = (pos: SileoPosition) =>\n\tpos.includes(\"right\") ? \"right\" : pos.includes(\"center\") ? \"center\" : \"left\";\nconst expandDir = (pos: SileoPosition) =>\n\tpos.startsWith(\"top\") ? (\"bottom\" as const) : (\"top\" as const);\n\n/* ---------------------------------- Types --------------------------------- */\n\ninterface InternalSileoOptions extends SileoOptions {\n\tid?: string;\n\tstate?: SileoState;\n}\n\ninterface SileoItem extends InternalSileoOptions {\n\tid: string;\n\tinstanceId: string;\n\texiting?: boolean;\n\tautoExpandDelayMs?: number;\n\tautoCollapseDelayMs?: number;\n}\n\ntype SileoOffsetValue = number | string;\ntype SileoOffsetConfig = Partial<\n\tRecord<\"top\" | \"right\" | \"bottom\" | \"left\", SileoOffsetValue>\n>;\n\nexport interface SileoToasterProps {\n\tchildren?: ReactNode;\n\tposition?: SileoPosition;\n\toffset?: SileoOffsetValue | SileoOffsetConfig;\n\toptions?: Partial<SileoOptions>;\n\ttheme?: 'light' | 'dark' | 'system';\n\tcloseButton?: boolean;\n\ttoastLimit?: number;\n}\n\n/* ------------------------------ Global State ------------------------------ */\n\ntype SileoListener = (toasts: SileoItem[]) => void;\n\nconst store = {\n\ttoasts: [] as SileoItem[],\n\tlisteners: new Set<SileoListener>(),\n\tposition: \"top-right\" as SileoPosition,\n\toptions: undefined as Partial<SileoOptions> | undefined,\n\ttoastLimit: DEFAULT_TOAST_LIMIT,\n\n\temit() {\n\t\tfor (const fn of this.listeners) fn(this.toasts);\n\t},\n\n\tupdate(fn: (prev: SileoItem[]) => SileoItem[]) {\n\t\tthis.toasts = fn(this.toasts);\n\t\tthis.emit();\n\t},\n};\n\nlet idCounter = 0;\nconst generateId = () =>\n\t`${++idCounter}-${Date.now().toString(36)}-${Math.random().toString(36).slice(2, 8)}`;\n\nconst timeoutKey = (t: SileoItem) => `${t.id}:${t.instanceId}`;\n\n/* ------------------------------- Toast API -------------------------------- */\n\nconst dismissToast = (id: string) => {\n\tconst item = store.toasts.find((t) => t.id === id);\n\tif (!item || item.exiting) return;\n\n\tstore.update((prev) =>\n\t\tprev.map((t) => (t.id === id ? { ...t, exiting: true } : t)),\n\t);\n\n\tsetTimeout(\n\t\t() => store.update((prev) => prev.filter((t) => t.id !== id)),\n\t\tEXIT_DURATION,\n\t);\n};\n\nconst resolveAutopilot = (\n\topts: InternalSileoOptions,\n\tduration: number | null,\n): { expandDelayMs?: number; collapseDelayMs?: number } => {\n\tif (opts.autopilot === false || !duration || duration <= 0) return {};\n\tconst cfg = typeof opts.autopilot === \"object\" ? opts.autopilot : undefined;\n\tconst clamp = (v: number) => Math.min(duration, Math.max(0, v));\n\treturn {\n\t\texpandDelayMs: clamp(cfg?.expand ?? AUTO_EXPAND_DELAY),\n\t\tcollapseDelayMs: clamp(cfg?.collapse ?? AUTO_COLLAPSE_DELAY),\n\t};\n};\n\nconst mergeOptions = (options: InternalSileoOptions) => ({\n\t...store.options,\n\t...options,\n\tstyles: { ...store.options?.styles, ...options.styles },\n});\n\nconst buildSileoItem = (\n\tmerged: InternalSileoOptions,\n\tid: string,\n\tfallbackPosition?: SileoPosition,\n): SileoItem => {\n\tconst duration = merged.duration ?? DEFAULT_TOAST_DURATION;\n\tconst auto = resolveAutopilot(merged, duration);\n\treturn {\n\t\t...merged,\n\t\tid,\n\t\tinstanceId: generateId(),\n\t\tposition: merged.position ?? fallbackPosition ?? store.position,\n\t\tautoExpandDelayMs: auto.expandDelayMs,\n\t\tautoCollapseDelayMs: auto.collapseDelayMs,\n\t};\n};\n\nconst createToast = (options: InternalSileoOptions) => {\n\tconst live = store.toasts.filter((t) => !t.exiting);\n\tconst merged = mergeOptions(options);\n\n\tconst id = merged.id ?? generateId();\n\tconst prev = live.find((t) => t.id === id);\n\tconst item = buildSileoItem(merged, id, prev?.position);\n\n\tif (prev) {\n\t\tstore.update((p) => p.map((t) => (t.id === id ? item : t)));\n\t} else {\n\t\tstore.update((p) => [...p.filter((t) => t.id !== id), item]);\n\t}\n\n\t// Store-level hard cap: auto-dismiss oldest when exceeding 3Ã— toastLimit\n\tconst hardCap = store.toastLimit * 3;\n\tconst liveAfter = store.toasts.filter((t) => !t.exiting);\n\tif (liveAfter.length > hardCap) {\n\t\tconst excess = liveAfter.slice(0, liveAfter.length - hardCap);\n\t\tfor (const t of excess) {\n\t\t\tdismissToast(t.id);\n\t\t}\n\t}\n\n\treturn { id, duration: merged.duration ?? DEFAULT_TOAST_DURATION };\n};\n\nconst updateToast = (id: string, options: InternalSileoOptions) => {\n\tconst existing = store.toasts.find((t) => t.id === id);\n\tif (!existing) return;\n\n\tconst item = buildSileoItem(mergeOptions(options), id, existing.position);\n\tstore.update((prev) => prev.map((t) => (t.id === id ? item : t)));\n};\n\nexport interface SileoPromiseOptions<T = unknown> {\n\tloading: Pick<SileoOptions, \"title\" | \"icon\">;\n\tsuccess: SileoOptions | ((data: T) => SileoOptions);\n\terror: SileoOptions | ((err: unknown) => SileoOptions);\n\taction?: SileoOptions | ((data: T) => SileoOptions);\n\tposition?: SileoPosition;\n}\n\nexport const sileo = {\n\tshow: (opts: SileoOptions) => createToast(opts).id,\n\tsuccess: (opts: SileoOptions) =>\n\t\tcreateToast({ ...opts, state: \"success\" }).id,\n\terror: (opts: SileoOptions) => createToast({ ...opts, state: \"error\" }).id,\n\twarning: (opts: SileoOptions) =>\n\t\tcreateToast({ ...opts, state: \"warning\" }).id,\n\tinfo: (opts: SileoOptions) => createToast({ ...opts, state: \"info\" }).id,\n\taction: (opts: SileoOptions) => createToast({ ...opts, state: \"action\" }).id,\n\n\tpromise: <T,>(\n\t\tpromise: Promise<T> | (() => Promise<T>),\n\t\topts: SileoPromiseOptions<T>,\n\t): Promise<T> => {\n\t\tconst { id } = createToast({\n\t\t\t...opts.loading,\n\t\t\tstate: \"loading\",\n\t\t\tduration: null,\n\t\t\tposition: opts.position,\n\t\t});\n\n\t\tconst p = typeof promise === \"function\" ? promise() : promise;\n\n\t\tp.then((data) => {\n\t\t\tif (opts.action) {\n\t\t\t\tconst actionOpts =\n\t\t\t\t\ttypeof opts.action === \"function\" ? opts.action(data) : opts.action;\n\t\t\t\tupdateToast(id, { ...actionOpts, state: \"action\", id });\n\t\t\t} else {\n\t\t\t\tconst successOpts =\n\t\t\t\t\ttypeof opts.success === \"function\"\n\t\t\t\t\t\t? opts.success(data)\n\t\t\t\t\t\t: opts.success;\n\t\t\t\tupdateToast(id, { ...successOpts, state: \"success\", id });\n\t\t\t}\n\t\t}).catch((err) => {\n\t\t\tconst errorOpts =\n\t\t\t\ttypeof opts.error === \"function\" ? opts.error(err) : opts.error;\n\t\t\tupdateToast(id, { ...errorOpts, state: \"error\", id });\n\t\t});\n\n\t\treturn p;\n\t},\n\n\tdismiss: dismissToast,\n\n\tclear: (position?: SileoPosition) =>\n\t\tstore.update((prev) =>\n\t\t\tposition ? prev.filter((t) => t.position !== position) : [],\n\t\t),\n};\n\n/* ------------------------------ Toaster Component ------------------------- */\n\nconst THEME_FILLS = {\n\tlight: '#FFFFFF',\n\tdark: '#1a1a1a',\n} as const;\n\nfunction useResolvedTheme(theme: 'light' | 'dark' | 'system' | undefined): 'light' | 'dark' {\n\tconst [resolved, setResolved] = useState<'light' | 'dark'>(() => {\n\t\tif (theme === 'light' || theme === 'dark') return theme;\n\t\tif (typeof window === 'undefined') return 'light';\n\t\treturn window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light';\n\t});\n\n\tuseEffect(() => {\n\t\tif (theme === 'light' || theme === 'dark') {\n\t\t\tsetResolved(theme);\n\t\t\treturn;\n\t\t}\n\t\tconst mq = window.matchMedia('(prefers-color-scheme: dark)');\n\t\tconst handler = (e: MediaQueryListEvent) => setResolved(e.matches ? 'dark' : 'light');\n\t\tsetResolved(mq.matches ? 'dark' : 'light');\n\t\tmq.addEventListener('change', handler);\n\t\treturn () => mq.removeEventListener('change', handler);\n\t}, [theme]);\n\n\treturn resolved;\n}\n\nexport function Toaster({\n\tchildren,\n\tposition = \"top-right\",\n\toffset,\n\toptions,\n\ttheme,\n\tcloseButton = false,\n\ttoastLimit = DEFAULT_TOAST_LIMIT,\n}: SileoToasterProps) {\n\tconst resolvedTheme = useResolvedTheme(theme);\n\tconst [toasts, setToasts] = useState<SileoItem[]>(store.toasts);\n\tconst [activeId, setActiveId] = useState<string>();\n\n\tconst hoverRef = useRef(false);\n\tconst timersRef = useRef(new Map<string, number>());\n\t// Track when each timer was started and its scheduled duration so we can\n\t// pause on hover and resume with the remaining time instead of resetting.\n\tconst timerMetaRef = useRef(new Map<string, { startedAt: number; duration: number }>());\n\tconst remainingRef = useRef(new Map<string, number>());\n\tconst listRef = useRef(toasts);\n\tconst latestRef = useRef<string | undefined>(undefined);\n\tconst handlersCache = useRef(\n\t\tnew Map<\n\t\t\tstring,\n\t\t\t{\n\t\t\t\tenter: MouseEventHandler<HTMLLIElement>;\n\t\t\t\tleave: MouseEventHandler<HTMLLIElement>;\n\t\t\t\tdismiss: () => void;\n\t\t\t}\n\t\t>(),\n\t);\n\n\tuseEffect(() => {\n\t\tstore.position = position;\n\t\tstore.toastLimit = toastLimit;\n\t\tconst fill = theme ? THEME_FILLS[resolvedTheme] : undefined;\n\t\tstore.options = fill ? { ...options, fill } : options;\n\t}, [position, options, theme, resolvedTheme, toastLimit]);\n\n\tconst clearAllTimers = useCallback(() => {\n\t\tfor (const t of timersRef.current.values()) clearTimeout(t);\n\t\ttimersRef.current.clear();\n\t\ttimerMetaRef.current.clear();\n\t}, []);\n\n\tconst scheduleItem = useCallback((item: SileoItem, overrideDur?: number) => {\n\t\tconst key = timeoutKey(item);\n\t\tif (timersRef.current.has(key)) return;\n\n\t\tconst dur = overrideDur ?? remainingRef.current.get(key) ?? (item.duration ?? DEFAULT_TOAST_DURATION);\n\t\tif (dur === null || dur <= 0) return;\n\n\t\t// Clean up any stale remaining entry\n\t\tremainingRef.current.delete(key);\n\n\t\ttimerMetaRef.current.set(key, { startedAt: Date.now(), duration: dur });\n\t\ttimersRef.current.set(\n\t\t\tkey,\n\t\t\twindow.setTimeout(() => {\n\t\t\t\ttimerMetaRef.current.delete(key);\n\t\t\t\tremainingRef.current.delete(key);\n\t\t\t\tdismissToast(item.id);\n\t\t\t}, dur),\n\t\t);\n\t}, []);\n\n\tconst schedule = useCallback((items: SileoItem[]) => {\n\t\tif (hoverRef.current) return;\n\t\tfor (const item of items) {\n\t\t\tif (item.exiting) continue;\n\t\t\tscheduleItem(item);\n\t\t}\n\t}, [scheduleItem]);\n\n\t// Pause all timers: snapshot remaining time per key, then clear.\n\tconst pauseAllTimers = useCallback(() => {\n\t\tconst now = Date.now();\n\t\tfor (const [key, meta] of timerMetaRef.current) {\n\t\t\tconst elapsed = now - meta.startedAt;\n\t\t\tconst left = Math.max(0, meta.duration - elapsed);\n\t\t\tremainingRef.current.set(key, left);\n\t\t}\n\t\tfor (const t of timersRef.current.values()) clearTimeout(t);\n\t\ttimersRef.current.clear();\n\t\ttimerMetaRef.current.clear();\n\t}, []);\n\n\tuseEffect(() => {\n\t\tconst listener: SileoListener = (next) => setToasts(next);\n\t\tstore.listeners.add(listener);\n\t\treturn () => {\n\t\t\tstore.listeners.delete(listener);\n\t\t\tclearAllTimers();\n\t\t};\n\t}, [clearAllTimers]);\n\n\tuseEffect(() => {\n\t\tlistRef.current = toasts;\n\n\t\tconst toastKeys = new Set(toasts.map(timeoutKey));\n\t\tconst toastIds = new Set(toasts.map((t) => t.id));\n\t\tfor (const [key, timer] of timersRef.current) {\n\t\t\tif (!toastKeys.has(key)) {\n\t\t\t\tclearTimeout(timer);\n\t\t\t\ttimersRef.current.delete(key);\n\t\t\t\ttimerMetaRef.current.delete(key);\n\t\t\t\tremainingRef.current.delete(key);\n\t\t\t}\n\t\t}\n\t\t// Also clean up remaining entries for removed toasts\n\t\tfor (const key of remainingRef.current.keys()) {\n\t\t\tif (!toastKeys.has(key)) remainingRef.current.delete(key);\n\t\t}\n\t\tfor (const id of handlersCache.current.keys()) {\n\t\t\tif (!toastIds.has(id)) handlersCache.current.delete(id);\n\t\t}\n\n\t\tschedule(toasts);\n\t}, [toasts, schedule]);\n\n\tconst handleMouseEnterRef =\n\t\tuseRef<MouseEventHandler<HTMLLIElement>>(null);\n\tconst handleMouseLeaveRef =\n\t\tuseRef<MouseEventHandler<HTMLLIElement>>(null);\n\n\thandleMouseEnterRef.current = useCallback<\n\t\tMouseEventHandler<HTMLLIElement>\n\t>(() => {\n\t\tif (hoverRef.current) return;\n\t\thoverRef.current = true;\n\t\tpauseAllTimers();\n\t}, [pauseAllTimers]);\n\n\thandleMouseLeaveRef.current = useCallback<\n\t\tMouseEventHandler<HTMLLIElement>\n\t>(() => {\n\t\tif (!hoverRef.current) return;\n\t\thoverRef.current = false;\n\t\tschedule(listRef.current);\n\t}, [schedule]);\n\n\tconst latest = useMemo(() => {\n\t\tfor (let i = toasts.length - 1; i >= 0; i--) {\n\t\t\tif (!toasts[i].exiting) return toasts[i].id;\n\t\t}\n\t\treturn undefined;\n\t}, [toasts]);\n\n\tuseEffect(() => {\n\t\tlatestRef.current = latest;\n\t\tsetActiveId(latest);\n\t}, [latest]);\n\n\tconst getHandlers = useCallback((toastId: string) => {\n\t\tlet cached = handlersCache.current.get(toastId);\n\t\tif (cached) return cached;\n\n\t\tcached = {\n\t\t\tenter: ((e) => {\n\t\t\t\tsetActiveId((prev) => (prev === toastId ? prev : toastId));\n\t\t\t\thandleMouseEnterRef.current?.(e);\n\t\t\t}) as MouseEventHandler<HTMLLIElement>,\n\t\t\tleave: ((e) => {\n\t\t\t\tsetActiveId((prev) =>\n\t\t\t\t\tprev === latestRef.current ? prev : latestRef.current,\n\t\t\t\t);\n\t\t\t\thandleMouseLeaveRef.current?.(e);\n\t\t\t}) as MouseEventHandler<HTMLLIElement>,\n\t\t\tdismiss: () => dismissToast(toastId),\n\t\t};\n\n\t\thandlersCache.current.set(toastId, cached);\n\t\treturn cached;\n\t}, []);\n\n\tconst getViewportStyle = useCallback(\n\t\t(pos: SileoPosition): CSSProperties | undefined => {\n\t\t\tif (offset === undefined) return undefined;\n\n\t\t\tconst o =\n\t\t\t\ttypeof offset === \"object\"\n\t\t\t\t\t? offset\n\t\t\t\t\t: { top: offset, right: offset, bottom: offset, left: offset };\n\n\t\t\tconst s: CSSProperties = {};\n\t\t\tconst px = (v: SileoOffsetValue) =>\n\t\t\t\ttypeof v === \"number\" ? `${v}px` : v;\n\n\t\t\tif (pos.startsWith(\"top\") && o.top) s.top = px(o.top);\n\t\t\tif (pos.startsWith(\"bottom\") && o.bottom) s.bottom = px(o.bottom);\n\t\t\tif (pos.endsWith(\"left\") && o.left) s.left = px(o.left);\n\t\t\tif (pos.endsWith(\"right\") && o.right) s.right = px(o.right);\n\n\t\t\treturn s;\n\t\t},\n\t\t[offset],\n\t);\n\n\tconst activePositions = useMemo(() => {\n\t\tconst map = new Map<SileoPosition, SileoItem[]>();\n\t\tfor (const t of toasts) {\n\t\t\tconst pos = t.position ?? position;\n\t\t\tconst arr = map.get(pos);\n\t\t\tif (arr) {\n\t\t\t\tarr.push(t);\n\t\t\t} else {\n\t\t\t\tmap.set(pos, [t]);\n\t\t\t}\n\t\t}\n\t\treturn map;\n\t}, [toasts, position]);\n\n\treturn (\n\t\t<>\n\t\t\t{children}\n\t\t\t{Array.from(activePositions, ([pos, items]) => {\n\t\t\t\tconst pill = pillAlign(pos);\n\t\t\t\tconst expand = expandDir(pos);\n\n\t\t\t\t// Visibility split: only the first toastLimit non-exiting toasts are visible\n\t\t\t\tlet visibleCount = 0;\n\t\t\t\tconst visibilityMap = new Map<string, boolean>();\n\t\t\t\tfor (const item of items) {\n\t\t\t\t\tif (item.exiting) {\n\t\t\t\t\t\tvisibilityMap.set(item.id, true);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tvisibleCount++;\n\t\t\t\t\t\tvisibilityMap.set(item.id, visibleCount <= toastLimit);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn (\n\t\t\t\t\t<section\n\t\t\t\t\t\tkey={pos}\n\t\t\t\t\t\tdata-sileo-viewport\n\t\t\t\t\t\tdata-position={pos}\n\t\t\t\t\t\tdata-theme={theme ? resolvedTheme : undefined}\n\t\t\t\t\t\taria-live=\"polite\"\n\t\t\t\t\t\tstyle={getViewportStyle(pos)}\n\t\t\t\t\t>\n\t\t\t\t\t\t<ol data-sileo-list>\n\t\t\t\t\t\t\t{items.map((item) => {\n\t\t\t\t\t\t\t\tconst h = getHandlers(item.id);\n\t\t\t\t\t\t\t\tconst visible = visibilityMap.get(item.id) ?? true;\n\t\t\t\t\t\t\t\treturn (\n\t\t\t\t\t\t\t\t\t<Sileo\n\t\t\t\t\t\t\t\t\t\tkey={item.id}\n\t\t\t\t\t\t\t\t\t\tid={item.id}\n\t\t\t\t\t\t\t\t\t\tstate={item.state}\n\t\t\t\t\t\t\t\t\t\ttitle={item.title}\n\t\t\t\t\t\t\t\t\t\tdescription={item.description}\n\t\t\t\t\t\t\t\t\t\tposition={pill}\n\t\t\t\t\t\t\t\t\t\texpand={expand}\n\t\t\t\t\t\t\t\t\t\ticon={item.icon}\n\t\t\t\t\t\t\t\t\t\tfill={item.fill}\n\t\t\t\t\t\t\t\t\t\tstyles={item.styles}\n\t\t\t\t\t\t\t\t\t\tbutton={item.button}\n\t\t\t\t\t\t\t\t\t\troundness={item.roundness}\n\t\t\t\t\t\t\t\t\t\texiting={item.exiting}\n\t\t\t\t\t\t\t\t\t\tautoExpandDelayMs={item.autoExpandDelayMs}\n\t\t\t\t\t\t\t\t\t\tautoCollapseDelayMs={item.autoCollapseDelayMs}\n\t\t\t\t\t\t\t\t\t\trefreshKey={item.instanceId}\n\t\t\t\t\t\t\t\t\t\tcanExpand={activeId === undefined || activeId === item.id}\n\t\t\t\t\t\t\t\t\t\tonMouseEnter={h.enter}\n\t\t\t\t\t\t\t\t\t\tonMouseLeave={h.leave}\n\t\t\t\t\t\t\t\t\t\tonDismiss={h.dismiss}\n\t\t\t\t\t\t\t\t\t\tcloseButton={closeButton}\n\t\t\t\t\t\t\t\t\t\tvisible={visible}\n\t\t\t\t\t\t\t\t\t/>\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t})}\n\t\t\t\t\t\t</ol>\n\t\t\t\t\t</section>\n\t\t\t\t);\n\t\t\t})}\n\t\t</>\n\t);\n}\n","import { sileo } from \"./toast\";\nimport type { ReactNode } from \"react\";\nimport type { SileoOptions } from \"./types\";\n\ninterface SonnerCompatOptions {\n\tdescription?: ReactNode | string;\n\tduration?: number | null;\n\taction?: { label: string; onClick: () => void };\n\tid?: string;\n}\n\nfunction mapOptions(\n\tmsg: string | ReactNode,\n\topts?: SonnerCompatOptions,\n): SileoOptions & { id?: string } {\n\tconst title = typeof msg === \"string\" ? msg : \"Notification\";\n\tconst description = typeof msg !== \"string\" ? msg : opts?.description;\n\treturn {\n\t\ttitle,\n\t\tdescription,\n\t\tduration:\n\t\t\topts?.duration === Infinity\n\t\t\t\t? null\n\t\t\t\t: opts?.duration === undefined\n\t\t\t\t\t? undefined\n\t\t\t\t\t: opts.duration,\n\t\tbutton: opts?.action\n\t\t\t? { title: opts.action.label, onClick: opts.action.onClick }\n\t\t\t: undefined,\n\t\tid: opts?.id,\n\t};\n}\n\ntype ToastFn = {\n\t(msg: string | ReactNode, opts?: SonnerCompatOptions): string;\n\tsuccess: (msg: string | ReactNode, opts?: SonnerCompatOptions) => string;\n\terror: (msg: string | ReactNode, opts?: SonnerCompatOptions) => string;\n\twarning: (msg: string | ReactNode, opts?: SonnerCompatOptions) => string;\n\tinfo: (msg: string | ReactNode, opts?: SonnerCompatOptions) => string;\n\tdismiss: typeof sileo.dismiss;\n\tpromise: typeof sileo.promise;\n};\n\nconst _toast = (msg: string | ReactNode, opts?: SonnerCompatOptions) =>\n\tsileo.show(mapOptions(msg, opts));\n\nexport const toast: ToastFn = Object.assign(_toast, {\n\tsuccess: (msg: string | ReactNode, opts?: SonnerCompatOptions) =>\n\t\tsileo.success(mapOptions(msg, opts)),\n\terror: (msg: string | ReactNode, opts?: SonnerCompatOptions) =>\n\t\tsileo.error(mapOptions(msg, opts)),\n\twarning: (msg: string | ReactNode, opts?: SonnerCompatOptions) =>\n\t\tsileo.warning(mapOptions(msg, opts)),\n\tinfo: (msg: string | ReactNode, opts?: SonnerCompatOptions) =>\n\t\tsileo.info(mapOptions(msg, opts)),\n\tdismiss: sileo.dismiss,\n\tpromise: sileo.promise,\n});\n"],"names":[],"mappings":";;AACO,KAAA,UAAA;AACA,UAAA,WAAA;AACP;AACA;AACA;AACA;AACA;AACO,UAAA,WAAA;AACP;AACA;AACA;AACO,cAAA,eAAA;AACA,KAAA,aAAA,WAAA,eAAA;AACA,UAAA,YAAA;AACP;AACA,kBAAA,SAAA;AACA,eAAA,aAAA;AACA;AACA,WAAA,SAAA;AACA,aAAA,WAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAA,WAAA;AACA;;AC1BA,KAAA,gBAAA;AACA,KAAA,iBAAA,GAAA,OAAA,CAAA,MAAA,sCAAA,gBAAA;AACO,UAAA,iBAAA;AACP,eAAA,SAAA;AACA,eAAA,aAAA;AACA,aAAA,gBAAA,GAAA,iBAAA;AACA,cAAA,OAAA,CAAA,YAAA;AACA;AACA;AACA;AACA;AACO,UAAA,mBAAA;AACP,aAAA,IAAA,CAAA,YAAA;AACA,aAAA,YAAA,iBAAA,YAAA;AACA,WAAA,YAAA,sBAAA,YAAA;AACA,aAAA,YAAA,iBAAA,YAAA;AACA,eAAA,aAAA;AACA;AACO,cAAA,KAAA;AACP,iBAAA,YAAA;AACA,oBAAA,YAAA;AACA,kBAAA,YAAA;AACA,oBAAA,YAAA;AACA,iBAAA,YAAA;AACA,mBAAA,YAAA;AACA,0BAAA,OAAA,aAAA,OAAA,YAAA,mBAAA,QAAA,OAAA;AACA;AACA,uBAAA,aAAA;AACA;AACO,iBAAA,OAAA,2EAAA,iBAAA;;AC7BP,UAAA,mBAAA;AACA,kBAAA,SAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAA,OAAA;AACA,mBAAA,SAAA,SAAA,mBAAA;AACA,4BAAA,SAAA,SAAA,mBAAA;AACA,0BAAA,SAAA,SAAA,mBAAA;AACA,4BAAA,SAAA,SAAA,mBAAA;AACA,yBAAA,SAAA,SAAA,mBAAA;AACA,oBAAA,KAAA,CAAA,OAAA;AACA,oBAAA,KAAA,CAAA,OAAA;AACA;AACO,cAAA,KAAA,EAAA,OAAA;;;;"}